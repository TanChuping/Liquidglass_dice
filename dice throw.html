<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Liquid Dice 21:9 Ultimate</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; font-family: sans-serif; touch-action: none; /* ç¦æ­¢æµè§ˆå™¨é»˜è®¤ç¼©æ”¾ */ }
        
        #canvas-container { width: 100vw; height: 100vh; display: block; }

        /* UI å±‚ */
        #ui-layer {
            position: absolute; bottom: 30px; left: 0; width: 100%;
            text-align: center; pointer-events: none;
            color: rgba(255,255,255,0.5); font-size: 13px; letter-spacing: 1px;
            text-shadow: 0 2px 4px rgba(0,0,0,0.8);
            z-index: 10;
        }
        b { color: white; }

        /* --- æ¶²æ€é‡ç½®æŒ‰é’® --- */
        #reset-btn {
            position: absolute; top: 20px; right: 20px;
            width: 50px; height: 50px;
            border-radius: 16px;
            cursor: pointer;
            z-index: 20;
            pointer-events: auto;
            
            /* æ¶²æ€ç»ç’ƒè´¨æ„Ÿ CSS æ¨¡æ‹Ÿ */
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(15px);
            -webkit-backdrop-filter: blur(15px);
            border: 1px solid rgba(255, 255, 255, 0.25);
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            border-right: 1px solid rgba(255, 255, 255, 0.1);
            
            box-shadow: 
                0 10px 30px rgba(0, 0, 0, 0.3),
                inset 0 0 0 1px rgba(255, 255, 255, 0.1),
                inset 0 0 10px rgba(255, 255, 255, 0.1);
            
            display: flex; align-items: center; justify-content: center;
            color: white; font-size: 20px;
            transition: all 0.2s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }

        /* å†…éƒ¨å›¾æ ‡ */
        #reset-btn svg { fill: white; opacity: 0.8; width: 24px; height: 24px; filter: drop-shadow(0 2px 3px rgba(0,0,0,0.3)); }

        /* æ‚¬åœé«˜å…‰ */
        #reset-btn:hover {
            background: rgba(255, 255, 255, 0.15);
            box-shadow: 0 0 15px rgba(255, 255, 255, 0.3), inset 0 0 20px rgba(255, 255, 255, 0.2);
            transform: translateY(-2px);
        }

        /* ç‚¹å‡»åŠ¨ç”»ï¼šå˜å° + é«˜å…‰çˆ†å‘ */
        #reset-btn:active {
            transform: scale(0.9);
            background: rgba(255, 255, 255, 0.3);
            box-shadow: 0 0 5px rgba(255, 255, 255, 0.5), inset 0 0 30px rgba(255, 255, 255, 0.4);
            border-color: rgba(255, 255, 255, 0.6);
        }
    </style>
</head>
<body>

    <div id="reset-btn" onclick="resetDice()">
        <svg viewBox="0 0 24 24"><path d="M17.65 6.35C16.2 4.9 14.21 4 12 4c-4.42 0-7.99 3.58-7.99 8s3.57 8 7.99 8c3.73 0 6.84-2.55 7.73-6h-2.08c-.82 2.33-3.04 4-5.65 4-3.31 0-6-2.69-6-6s2.69-6 6-6c1.66 0 3.14.69 4.22 1.78L13 11h7V4l-2.35 2.35z"/></svg>
    </div>

    <div id="ui-layer">
        <div><b>Liquid Glass 21:9</b></div>
        <span style="font-size:11px; opacity:0.7;">
            ğŸ–±ï¸ Scroll to Lift &bull; ğŸ‘† Drag to Throw
        </span>
    </div>

    <div id="canvas-container"></div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/",
                "cannon-es": "https://unpkg.com/cannon-es@0.20.0/dist/cannon-es.js"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { RoundedBoxGeometry } from 'three/addons/geometries/RoundedBoxGeometry.js';
        import * as CANNON from 'cannon-es';

        // ==========================================
        // 1. åˆå§‹åŒ–åœºæ™¯ (Scene Setup)
        // ==========================================
        const container = document.getElementById('canvas-container');
        const scene = new THREE.Scene();
        
        // ç›¸æœºä½ç½®ï¼šæ‹‰è¿œä¸€ç‚¹ä»¥é€‚åº”ä¸åŒé•¿å®½æ¯”
        const cameraDistance = 18;
        const camera = new THREE.PerspectiveCamera(40, window.innerWidth / window.innerHeight, 0.1, 100);
        camera.position.set(0, 14, cameraDistance); 
        camera.lookAt(0, 0, 0);

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.SoftShadowMap;
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        container.appendChild(renderer.domElement);

        // èƒŒæ™¯
        const texLoader = new THREE.TextureLoader();
        const bgTexture = texLoader.load('https://images.unsplash.com/photo-1550684848-fac1c5b4e853?q=80&w=2070&auto=format&fit=crop');
        scene.background = bgTexture;
        scene.environment = bgTexture;

        // ==========================================
        // 2. ç‰©ç†ä¸–ç•Œ (Physics World)
        // ==========================================
        const world = new CANNON.World();
        world.gravity.set(0, -30, 0);
        world.broadphase = new CANNON.SAPBroadphase(world);
        world.allowSleep = true;

        const defaultMat = new CANNON.Material('default');
        const defaultContact = new CANNON.ContactMaterial(defaultMat, defaultMat, {
            friction: 0.3, restitution: 0.5
        });
        world.addContactMaterial(defaultContact);

        // åœ°é¢
        const groundBody = new CANNON.Body({ mass: 0, shape: new CANNON.Plane(), material: defaultMat });
        groundBody.quaternion.setFromEuler(-Math.PI / 2, 0, 0);
        world.addBody(groundBody);

        // é˜´å½±å¹³é¢ (Visual Only)
        const shadowPlane = new THREE.Mesh(new THREE.PlaneGeometry(100, 100), new THREE.ShadowMaterial({ opacity: 0.4 }));
        shadowPlane.rotation.x = -Math.PI / 2;
        shadowPlane.position.y = 0.02;
        shadowPlane.receiveShadow = true;
        scene.add(shadowPlane);

        // --- åŠ¨æ€è¾¹ç•Œå¢™ (Smart Boundaries) ---
        // 21:9 ä¼˜åŒ–æ ¸å¿ƒï¼šæ ¹æ®æ‘„åƒæœºè§†é”¥è®¡ç®—å¢™å£ä½ç½®
        const walls = [];
        const wallShape = new CANNON.Box(new CANNON.Vec3(1, 20, 20)); // åšåº¦1çš„å¢™

        function updateWalls() {
            // ç§»é™¤æ—§å¢™
            walls.forEach(w => world.removeBody(w));
            walls.length = 0;

            // è®¡ç®—è§†é”¥ä½“åœ¨åœ°é¢(y=0)çš„å®½åº¦å’Œé«˜åº¦
            // vFOV æ˜¯å‚ç›´è§†è§’ï¼Œaspect æ˜¯å®½é«˜æ¯”
            const vFOV = THREE.MathUtils.degToRad(camera.fov);
            // è®¡ç®—æ‘„åƒæœºåˆ°åœ°é¢çš„å‚ç›´è·ç¦»
            const height = camera.position.y;
            // å¯è§†é«˜åº¦çš„ä¸€åŠ
            const visibleHeight = 2 * Math.tan(vFOV / 2) * Math.abs(camera.position.z / Math.cos(Math.atan(camera.position.y / camera.position.z))); 
            // ç®€å•ä¼°ç®—ï¼šåŸºäºz distanceçš„è§†é‡èŒƒå›´
            // æ›´ç²¾ç¡®çš„åšæ³•ï¼šraycast corners
            
            // ç®€åŒ–ç®—æ³•ï¼šæ ¹æ®å±å¹•æ¯”ä¾‹åŠ¨æ€è®¾ç½®å¢™è·
            // åŸºç¡€è·ç¦» 10ï¼Œéšå®½é«˜æ¯”è°ƒæ•´
            const aspect = window.innerWidth / window.innerHeight;
            let limitX = 8 * aspect; // å®½åº¦éšå±å¹•å˜å®½
            let limitZ = 12; // æ·±åº¦ç›¸å¯¹å›ºå®š

            // é’ˆå¯¹è¶…å®½å±/è¶…é•¿å±çš„é™åˆ¶
            if (aspect < 0.6) { // ç«–å±æ‰‹æœº 9:16 æˆ– 9:21
                limitX = 6; 
                limitZ = 14;
            } else if (aspect > 2) { // 21:9 æ¨ªå±
                limitX = 14;
            }

            const createWall = (x, z, rotY) => {
                const b = new CANNON.Body({ mass: 0, shape: wallShape, material: defaultMat });
                b.position.set(x, 10, z); // é«˜åº¦æŠ¬é«˜ç¡®ä¿è¦†ç›–
                b.quaternion.setFromEuler(0, rotY, 0);
                world.addBody(b);
                walls.push(b);
            };

            // åˆ›å»ºå››é¢å¢™ (ç¨å¾®ç•™ç‚¹ä½™é‡é˜²æ­¢ç©¿æ¨¡)
            createWall(limitX + 2, 0, 0);      // å³
            createWall(-(limitX + 2), 0, 0);   // å·¦
            createWall(0, -(limitZ + 2), Math.PI/2); // ä¸Š
            createWall(0, limitZ + 2, Math.PI/2);    // ä¸‹
        }
        
        // åˆå§‹åŒ–å¢™å£
        updateWalls();

        // ==========================================
        // 3. éª°å­çº¹ç†ç”Ÿæˆ (Texture Gen)
        // ==========================================
        function createDiceTexture(number) {
            const canvas = document.createElement('canvas');
            canvas.width = 256; canvas.height = 256;
            const ctx = canvas.getContext('2d');
            ctx.clearRect(0, 0, 256, 256);
            ctx.fillStyle = '#000000';
            const r = 32; 
            const drawDot = (x, y) => { ctx.beginPath(); ctx.arc(x, y, r, 0, Math.PI * 2); ctx.fill(); };
            const c = 128, g = 68;
            
            if (number===1) drawDot(c,c);
            if (number===2) { drawDot(c-g,c-g); drawDot(c+g,c+g); }
            if (number===3) { drawDot(c-g,c-g); drawDot(c,c); drawDot(c+g,c+g); }
            if (number===4) { drawDot(c-g,c-g); drawDot(c+g,c-g); drawDot(c-g,c+g); drawDot(c+g,c+g); }
            if (number===5) { drawDot(c-g,c-g); drawDot(c+g,c-g); drawDot(c,c); drawDot(c-g,c+g); drawDot(c+g,c+g); }
            if (number===6) { drawDot(c-g,c-g); drawDot(c+g,c-g); drawDot(c-g,c); drawDot(c+g,c); drawDot(c-g,c+g); drawDot(c+g,c+g); }
            return new THREE.CanvasTexture(canvas);
        }
        const textures = [null, createDiceTexture(1), createDiceTexture(2), createDiceTexture(3), createDiceTexture(4), createDiceTexture(5), createDiceTexture(6)];

        // ==========================================
        // 4. éª°å­æ„å»º (Core + Skin)
        // ==========================================
        const diceSize = 2.5;
        const diceMesh = new THREE.Group();

        // Core: çº¯å‡€æ¶²æ€ç»ç’ƒ (ä¿æŒä¸å˜!)
        const glassGeo = new RoundedBoxGeometry(diceSize, diceSize, diceSize, 10, 0.5);
        const glassMat = new THREE.MeshPhysicalMaterial({
            color: 0xffffff,
            metalness: 0.0, roughness: 0.0,
            transmission: 1.0, thickness: 3.5, ior: 1.5,
            clearcoat: 1.0, clearcoatRoughness: 0.05,
            side: THREE.DoubleSide
        });
        const coreMesh = new THREE.Mesh(glassGeo, glassMat);
        coreMesh.castShadow = true;
        diceMesh.add(coreMesh);

        // Skin: å•å‘é€è§†è¡¨çš® (ä¿æŒä¸å˜!)
        const skinGeo = new RoundedBoxGeometry(diceSize + 0.005, diceSize + 0.005, diceSize + 0.005, 10, 0.5);
        const skinMaterials = [
            new THREE.MeshBasicMaterial({ map: textures[1], transparent: true, side: THREE.FrontSide }),
            new THREE.MeshBasicMaterial({ map: textures[6], transparent: true, side: THREE.FrontSide }),
            new THREE.MeshBasicMaterial({ map: textures[2], transparent: true, side: THREE.FrontSide }),
            new THREE.MeshBasicMaterial({ map: textures[5], transparent: true, side: THREE.FrontSide }),
            new THREE.MeshBasicMaterial({ map: textures[3], transparent: true, side: THREE.FrontSide }),
            new THREE.MeshBasicMaterial({ map: textures[4], transparent: true, side: THREE.FrontSide }),
        ];
        const skinMesh = new THREE.Mesh(skinGeo, skinMaterials);
        diceMesh.add(skinMesh);

        scene.add(diceMesh);

        // ç‰©ç†åˆšä½“
        const diceShape = new CANNON.Box(new CANNON.Vec3(diceSize/2, diceSize/2, diceSize/2));
        const diceBody = new CANNON.Body({ mass: 10, shape: diceShape, material: defaultMat });
        diceBody.position.set(0, 5, 0);
        diceBody.angularVelocity.set(1, 1, 0);
        world.addBody(diceBody);

        // ç¯å…‰
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
        scene.add(ambientLight);
        const spotLight = new THREE.SpotLight(0xffffff, 2.0);
        spotLight.position.set(10, 25, 10);
        spotLight.angle = Math.PI/6; spotLight.penumbra = 0.5;
        spotLight.castShadow = true;
        spotLight.shadow.mapSize.set(2048, 2048);
        scene.add(spotLight);
        const rimLight = new THREE.PointLight(0x00ffff, 3, 20);
        rimLight.position.set(-8, 5, -8);
        scene.add(rimLight);

        // ==========================================
        // 5. äº¤äº’é€»è¾‘ (Interaction)
        // ==========================================
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();
        const dragPlane = new THREE.Plane(new THREE.Vector3(0, 1, 0), 0);
        
        // è™šæ‹ŸæŠ“æ‰‹
        const mouseBody = new CANNON.Body({ mass: 0, type: CANNON.Body.KINEMATIC });
        mouseBody.collisionFilterGroup = 0;
        world.addBody(mouseBody);
        
        let constraint = null;
        let isHolding = false;
        let targetHeight = 3.0; // åˆå§‹æ‚¬æµ®é«˜åº¦

        // å…¨å±€æš´éœ² reset å‡½æ•°ç»™æŒ‰é’®è°ƒç”¨
        window.resetDice = function() {
            // ç§»é™¤çº¦æŸ
            if (constraint) {
                world.removeConstraint(constraint);
                constraint = null;
                isHolding = false;
                document.body.style.cursor = 'default';
            }

            // é‡ç½®ç‰©ç†çŠ¶æ€
            diceBody.position.set(0, 6, 0);
            diceBody.velocity.set(0, 0, 0);
            diceBody.angularVelocity.set(Math.random()*5, Math.random()*5, Math.random()*5); // ç»™ç‚¹éšæœºæ—‹è½¬
            diceBody.quaternion.set(0,0,0,1);
            diceBody.wakeUp();

            // é‡ç½®UIé«˜åº¦
            targetHeight = 3.0;
        };

        function getRayPoint(clientX, clientY) {
            mouse.x = (clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(clientY / window.innerHeight) * 2 + 1;
            raycaster.setFromCamera(mouse, camera);
            const target = new THREE.Vector3();
            // åœ¨å½“å‰ targetHeight å¹³é¢æŸ¥æ‰¾äº¤ç‚¹
            dragPlane.constant = -targetHeight; 
            raycaster.ray.intersectPlane(dragPlane, target);
            return target;
        }

        function grabDice(point) {
            isHolding = true;
            document.body.style.cursor = 'grabbing';
            diceBody.wakeUp();
            mouseBody.position.set(point.x, point.y, point.z);
            constraint = new CANNON.PointToPointConstraint(diceBody, new CANNON.Vec3(0,0,0), mouseBody, new CANNON.Vec3(0,0,0));
            world.addConstraint(constraint);
        }

        // --- æ»šè½®ä¿®å¤ (Scroll Fix) ---
        window.addEventListener('wheel', (e) => {
            e.preventDefault(); // é˜²æ­¢é¡µé¢æ»šåŠ¨
            
            // å¢åŠ çµæ•åº¦ (0.01 -> 0.005, æˆ–è€…æ ¹æ®deltaModeåˆ¤æ–­)
            const delta = e.deltaY * 0.005; 
            targetHeight += delta;
            targetHeight = Math.max(1.5, Math.min(targetHeight, 12)); // é™åˆ¶èŒƒå›´

            // æ— è®ºæ˜¯å¦æŠ“å–ï¼Œéƒ½æ›´æ–°mouseBodyçš„é«˜åº¦ï¼Œè¿™æ ·ä¸‹æ¬¡ç‚¹å‡»æˆ–è€…å½“å‰æŠ“å–éƒ½ä¼šå³æ—¶å“åº”
            if (isHolding) {
                // å¦‚æœæ­£åœ¨æŠ“å–ï¼Œåªæ›´æ–°Yè½´
                mouseBody.position.y = targetHeight;
                diceBody.wakeUp();
            }
        }, { passive: false }); // å…³é”®ï¼špassive: false å…è®¸ preventDefault

        // --- é¼ æ ‡äº‹ä»¶ ---
        window.addEventListener('mousedown', (e) => {
            if(e.target.closest('#reset-btn')) return; // é˜²æ­¢ç‚¹å‡»æŒ‰é’®è§¦å‘æŠ•æ·
            mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObject(skinMesh);
            if (intersects.length > 0) {
                // ç‚¹å‡»ç¬é—´ï¼Œä»¥æ­¤ä¸ºé«˜åº¦åŸºå‡†ï¼Œé˜²æ­¢è·³è·ƒï¼Œä½†ä¿ç•™ç¨å¾®æŠ¬èµ·çš„æ•ˆæœ
                targetHeight = Math.max(diceBody.position.y, 2.0); 
                const point = getRayPoint(e.clientX, e.clientY);
                if(point) grabDice(point);
            }
        });

        window.addEventListener('mousemove', (e) => {
            if (isHolding) {
                const point = getRayPoint(e.clientX, e.clientY);
                if (point) {
                    mouseBody.position.x = point.x;
                    mouseBody.position.z = point.z;
                    mouseBody.position.y = targetHeight; // å¼ºåˆ¶åŒæ­¥é«˜åº¦
                    diceBody.wakeUp();
                }
            } else {
                // Hover Cursor
                mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
                mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;
                raycaster.setFromCamera(mouse, camera);
                const intersects = raycaster.intersectObject(skinMesh);
                document.body.style.cursor = intersects.length > 0 ? 'grab' : 'default';
            }
        });

        window.addEventListener('mouseup', () => {
            if (isHolding) {
                isHolding = false;
                document.body.style.cursor = 'default';
                world.removeConstraint(constraint);
                constraint = null;
            }
        });

        // --- è§¦æ§äº‹ä»¶ (Touch) ---
        window.addEventListener('touchstart', (e) => {
            if(e.target.closest('#reset-btn')) return;
            e.preventDefault();
            const touch = e.touches[0];
            mouse.x = (touch.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(touch.clientY / window.innerHeight) * 2 + 1;
            raycaster.setFromCamera(mouse, camera);
            if (raycaster.intersectObject(skinMesh).length > 0) {
                targetHeight = 5; // è§¦æ§é»˜è®¤æŠ¬é«˜
                const point = getRayPoint(touch.clientX, touch.clientY);
                if(point) grabDice(point);
            }
        }, { passive: false });

        window.addEventListener('touchmove', (e) => {
            e.preventDefault();
            if (isHolding) {
                const touch = e.touches[0];
                const point = getRayPoint(touch.clientX, touch.clientY);
                if (point) {
                    mouseBody.position.x = point.x;
                    mouseBody.position.z = point.z;
                    mouseBody.position.y = targetHeight;
                    diceBody.wakeUp();
                }
            }
        }, { passive: false });

        window.addEventListener('touchend', () => {
            if (isHolding) {
                isHolding = false;
                world.removeConstraint(constraint);
                constraint = null;
            }
        });

        // ==========================================
        // 6. æ¸²æŸ“å¾ªç¯
        // ==========================================
        const clock = new THREE.Clock();
        function animate() {
            requestAnimationFrame(animate);
            const dt = Math.min(clock.getDelta(), 0.1);
            world.step(1/60, dt, 3);
            diceMesh.position.copy(diceBody.position);
            diceMesh.quaternion.copy(diceBody.quaternion);
            renderer.render(scene, camera);
        }
        animate();

        // çª—å£è°ƒæ•´ï¼šé‡æ–°è®¡ç®—å¢™å£
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            updateWalls(); // å…³é”®ï¼šçª—å£å˜åŒ–æ—¶æ›´æ–°ç‰©ç†è¾¹ç•Œ
        });
    </script>
</body>
</html>